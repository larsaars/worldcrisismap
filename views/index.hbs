{{> menu }}

<div class="w3-sidebar w3-bar-block w3-card" id="sidebar">
    <div id="sidebarContent" class="p-3">
        <div class="row sticky-top">
            <div class="col-sm-12">

                <button type="button" class="w3-button w3-large float-end"
                        onclick="closeSideBar()">&times;
                </button>
            </div>
        </div>
        <div id="sidebarText" class="container"></div>
    </div>
</div>

<div id="main">
    <div id="map"></div>
</div>

<div id="earth"></div>

<script>
    // get map variable
    let map = new maplibregl.Map({
        container: 'map',
        style: 'https://api.maptiler.com/maps/streets/style.json?key=FmkZcpxnyFTMyvbqcIqk',
        center: [0, 33],
        zoom: 2.2,
    });

    $(window).resize(function () {
        map.resize();
    });

    // add controls to map (zoom etc)
    map.addControl(new maplibregl.NavigationControl(), 'top-right');

    // list of markers for all events for hover functionality
    let markers = [];

    // the passed json data from the server
    const disasterData = {{{ disasterData }}};
    const newsData = {{{ newsData }}};


    // get disaster and news files from the server data
    let disasterFiles = [], newsFiles = [];

    // parse from json because they are passed as strings
    for (const data of disasterData) {
        disasterFiles.push(JSON.parse(data.geojson));
    }

    for (const data of newsData) {
        newsFiles.push(JSON.parse(data.geojson));
    }
    // generate colors for all events
    const [disasterColors, newsColors] = generateRandomColors(disasterData.length, newsData.length);

    // variables for geo json
    let disasterGeoJson, newsGeoJson;
    let firstSymbolId;

    map.on('load', async function () {
        let layers = map.getStyle().layers;
        // find the index of the first symbol layer in the map style
        for (let i = 0; i < layers.length; i++) {
            if (layers[i].type === 'symbol') {
                firstSymbolId = layers[i].id;
                break;
            }
        }

        // geo json variables
        disasterGeoJson = await buildGeoJSON(disasterFiles, disasterColors, true);
        newsGeoJson = await buildGeoJSON(newsFiles, newsColors, false);

        // build sources from provided geo json files
        map.addSource('disasters', {
            'type': 'geojson',
            'data': disasterGeoJson
        });
        map.addSource('news', {
            'type': 'geojson',
            'data': newsGeoJson
        });

        // add news and disaster layer
        map.addLayer(
                {
                    'id': 'disasters-layer',
                    'type': 'fill',
                    'source': 'disasters',
                    'layout': {},
                    'paint': {
                        'fill-color': ['get', 'fill'],
                        'fill-opacity': 0.4
                    }
                },
                firstSymbolId
        );
        map.addLayer(
                {
                    'id': 'news-layer',
                    'type': 'fill',
                    'source': 'news',
                    'layout': {},
                    'paint': {
                        'fill-color': ['get', 'fill'],
                        'fill-opacity': 0.4
                    }
                },
                firstSymbolId
        );

        // add markers for every event to the map
        function addMarkers(dataList, colors, isDisaster) {
            for (const dataIndex in dataList) {
                const data = dataList[dataIndex];
                // define event type text
                const eventType = data.type ? data.type : 'News';

                // create marker icon
                const markerIcon = document.createElement('div');
                markerIcon.style.width = '32px';
                markerIcon.style.height = '32px';
                markerIcon.style.backgroundSize = 'contain';
                markerIcon.style.backgroundImage = getMarkerImage(eventType, useBlack(colors[dataIndex]));
                markerIcon.style.cursor = 'pointer';
                markerIcon.style.backgroundColor = colors[dataIndex];
                markerIcon.style.borderRadius = '50%';
                markerIcon.style.border = '1px solid ' + colors[dataIndex];
                markerIcon.style.opacity = '0.72';

                // create marker with popup
                const marker = new maplibregl.Marker(markerIcon, {
                    color: colors[dataIndex],
                    draggable: false,
                    anchor: 'center',
                }).setLngLat([data.lon, data.lat]);

                // set description attribute to marker to be used in sidebar text (with formatted date)
                const dateString = new Date(data.date).toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                });

                marker.description = '<p><i>' + eventType + '</i><p><small>' + dateString + '</small></p><h2>' + data.title + '</h2><br>' + data.description_html.replace(/&quot;/g, '"');

                // set color of marker to be used in sidebar text
                marker.color = colors[dataIndex];

                // set marker index for GeoJSON retrieval
                marker.eventIndex = dataIndex;
                marker.isDisaster = isDisaster

                // set coords to marker
                marker.lat = data.lat;
                marker.lon = data.lon;

                // add to map
                marker.addTo(map);

                // and to the list of markers
                markers.push(marker);
            }
        }

        // call addMarkers for disaster and news markers
        addMarkers(disasterData, disasterColors, true);
        addMarkers(newsData, newsColors, false);

        // go through all markers and change the positions of those with the same coordinates
        for (const marker of markers) {
            // get all markers with the same coordinates
            const sameMarkers = markers.filter(m => m.lat === marker.lat && m.lon === marker.lon);

            // if there is more than one marker with the same coordinates
            if (sameMarkers.length > 1) {
                // get the index of the current marker
                const index = sameMarkers.indexOf(marker);

                // calculate the offset for the current marker
                const offset = 32 * (index - (sameMarkers.length - 1) / 2);

                // set the offset
                marker.setOffset([offset, 0]);
            }
        }


        // remove loading circle (finished loading)
        $('#earth').hide();
    });


    // add on map click listener
    // for preventing popup from opening on click (only on hover)
    map.on('click', event => {
        const target = event.originalEvent.target;

        // boolean if marker was clicked
        let isMarker = false;

        // find the marker clicked
        for (const marker of markers) {
            // on match
            if (marker.getElement().contains(target)) {

                // open sidebar with description
                if (marker === selectedMarker) {
                    closeSideBar();
                } else {
                    openSideBar(map, marker, marker.isDisaster ? disasterGeoJson : newsGeoJson);
                }

                // is marker is true
                isMarker = true;

                break;
            }
        }

        // if this was no marker clicked, close sidebar
        if (!isMarker) {
            closeSideBar();
        }
    });
</script>
